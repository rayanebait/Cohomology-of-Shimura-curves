/*
	Evaluation function for straight line programs (slp).

	Given a group grp with multiplication function grp_mul, group
	powering function grp_pow, a set of generators grp_gens 
	aswell as an slp and pointers [slp, pointers]=slpdata
	evaluates the straight line program slp and outputs 
	(out[p[i]])_{i=1,...,#p}. 
*/
evalslp(grp_data, slpdata, {reverse=0}, {retout=0})={;
	my(grp, grp_mul, grp_pow, grp_gens, grp_unit);
	[grp, grp_mul, grp_pow, grp_gens]=grp_data;
	grp_unit=grp_pow(grp, grp_gens[1], 0);

	my(slp, pointers, n);
	slp=slpdata[1];
	n=#grp_gens;
	if(#slpdata==1, pointers=[#slp], pointers=slpdata[2]);

	my(out);
	out=concat(grp_gens, vector(#slp));

	my(i,j);
	for(k=1, #slp,
		[i,j]=slp[k];
		if(i<0,
			out[k+n]=grp_pow(grp, out[-i], j);
		,i==0,/*else if*/
			out[k+n]=out[j];
		,/*else*/
			if(reverse,
		    	out[k+n]=grp_mul(grp, out[j], out[i]);
			,/*else*/
		    	out[k+n]=grp_mul(grp, out[i], out[j]);
			);	
		);
	);	
	my(his);
	his=vector(#pointers,i, out[pointers[i]+n]);
	if(retout, return(out[(n+1)..#out]));
	return(his);
}

/*Same as evalslp but a subgroup of A generated by elts.*/
algevalslp(A, elts, slpdata, {reverse=0}, {retout=0},{h=0})={
	my(slp, pointers);
	slp=slpdata[1];
	if(#slpdata==1,
		n=#elts;
		return(algmulvec(A, elts, slptovec(slpdata[1],n)));
	,/*else*/
		pointers=slpdata[2];
	);

	my(one);
	one=algeltfromnf(A,1);

	my(n,out);
	n=#elts;
	out=concat(elts, vector(#slp));

	my(i,j);
	for(k=1, #slp,
		[i,j]=slp[k];
		if(abs(i)>=k+n || abs(j)>=k+n,
			error("Invalid slp in algevalslp.");
		);
		if(i<0,
			out[k+n]=algpow(A, out[-i], j);
		,i==0,/*else if*/
			out[k+n]=out[j];
		,/*else*/
			if(reverse,
		    	out[k+n]=algmul(A, out[j], out[i]);
			,/*else*/
		    	out[k+n]=algmul(A, out[i], out[j]);
			);	
		);
	);	
	my(his);
	his=vector(#pointers,i, out[pointers[i]+n]);
	if(retout, return(out[(n+1)..#out]));
	return(his);
}

/*Given a vector of slps slps with a vector of pointers, one
for each slp (or none), outputs a single slp which is a 
concatenation of slps and updates the pointers. If connect=1,
connects the trees of the slps by draw an edge from slps[i+1][1]
to slps[i][#slps[i]] */
slpconcat(slps, n, {oldpointers=0}, {connect=0})={
	if(#slps==0, return(slps));
	if(oldpointers && #slps!=#oldpointers, error("Not as much pointers as slps in slpconcat."));

	my(slp, cardslp);
	cardslp=0; 
	foreach(slps, sl, cardslp+=#sl);
	slp=concat(slps[1],vector(cardslp-#slps[1]+#slps));

	my(nbpointers, pointers);
	if(oldpointers,
		nbpointers=0;
		foreach(oldpointers, pt, nbpointers+=#pt);
		pointers=concat(oldpointers[1], vector(nbpointers-#oldpointers[1]));
	);

	my(k, l, i, j);
	k=#slps[1];
	if(oldpointers,
		l=#oldpointers[1];
	);
	for(u=2, #slps, 
	  	for(v=1, #slps[u],
			[i,j]=slps[u][v];
			if(v==1 && connect,
				if(-n<=i && i<0,
					slp[k+v]=[i,j];
					slp[k+1+v]=[n+k,n+k+1];
					k++;
				,i==0 && j<=n,/*else if*/
					slp[k+v]=[n+k,j];
				,i<=n,/*else if*/
					slp[k+v]=[n+k,i];
					k++;
					slp[k+v]=[n+k,j];
				,/*else*/
					error("Invalid slp in slpconcat.");
				);
			,/*else*/
				if(i<0,
					if(i<-n,
						[i,j]=[i-k,j];
					,/*else*/
						[i,j]=[i,j];
					);
				,i==0,/*else if*/
					if(j<=n,
						[i,j]=[0,j];
					,/*else*/
						[i,j]=[0,k+j];
					);
				,/*else*/
					[i,j]=[i+k, j];
				);
				slp[k+v]=[i,j];
	  		);
		);
		if(oldpointers,
			for(v=1, #oldpointers[u],
				pointers[l+v]=k+oldpointers[u][v];
			);
			l=l+#oldpointers[u];
		);
	  	k=k+#slps[u];
	);
	if(oldpointers, return([slp[1..k], pointers]));
	return(slp[1..k]);
}


/*Extracts a linear slp from slp starting at index k. */

/*Reads slp from slp[k] to slp[stop] with the
	following convention : let [i,j]=slp[l] 
	then either i>n or j>n (exclusive), put
	l=i-n or l=j-n and iterate.

If we encounter [-1,0] or [0,j] with
j<=n at slp[l] then put stop=l
and every i>n or j>n should be 
slid to the left by stop indices.

Doesn't handle slps with inputs of the form
[i,j] with i<=-1 and j!=0.
 */

slpextractone(slp, k,n)={
	my(jumps, jump, extractedslp);
	extractedslp=vector(k);
	jumps=vector(k);
   	jump=0;

	/*Read slp right to left to record jumps.*/
	my(i,j, m=1, l=k, stop);
	while(m<=k,
	/*Breaks before m==k in general.*/
		[i,j]=slp[l];
		extractedslp[m]=[i,j];
		if(i<0,
		/*[i,j]=[-1,0]*/
			stop=l;
			break;
		,i==0,/*else if*/
			if(j<=n,
				stop=l;
				break;
			,/*else*/
				/*[0,j] with n<j*/
				jumps[l]=l-(j-n)-1;
				l=j-n;
			);
		,/*else*/
			/*[i,j] with n<i and j<=n*/
			jumps[l]=l-(i-n)-1;
			l=i-n;
		);
		m++;
	);
	
	my(slide, slides);
	slide=0;

	/*Read slp left to right*/
	/*Compute how much to slide a reference index*/
	/*to the left.*/
	slides=vector(k, u, slide+=jumps[u]; slide);

	extractedslp=Vecrev(extractedslp[1..m]);
	/*reverse and left to right*/
	for(u=1, m,
		[i,j]=extractedslp[u];
		if(i<0,
			/*Happens only at u=1*/
			[i,j]=[-1,0];
		,i==0,
			if(j<=n,
			/*Happens only at u=1*/
			[i,j]=[0,j];
			,n<j,/*else if*/
			/*[0,j] with n<j*/
				[i,j]=[0,j-slides[j-n]-(stop-1)];
			);
		,i>0,/*else if*/
			[i,j]=[i-slides[i-n]-(stop-1), j];
		);
		extractedslp[u]=[i,j];
	);
	return(extractedslp);
}

/*Extracts all slps associated to the pointers into linear slps.*/

/*O(n^2) by nature, doesn't handle slps with 
  inputs of the form [i,j] with i<=-1 and j!=0*/
slpextract(slp,pointers,n)={
	my(extractedslps, k);
	/*O(n^2)*/
	extractedslps=vector(#pointers);
	for(i=1,#pointers,
		k=pointers[i];
		extractedslps[i]=slpextractone(slp,k,n);
	);
	return(extractedslps);
}

/*
   	Assumes slp is a linear slp with powers. And s is an involution
	of {1,...,n} representing an inversion involution. 
 */
slpinvert(slp,s,n)={
	my(m, i,j, invertedslp);
	m=#slp;
	invertedslp=vector(m);

	for(k=0, m-1,
		[i,j]=slp[m-k];
		if(i<0,
			if(i==-1 && j==0,
				if(k!=m-1, error("Invalid slp in slpinvert"));
				[i,j]=[0,k+n];
			,/*else*/
				/*TODO : VÃ©rifier que c'est correct*/
				/*Assumes i<=n*/
				[i,j]=[-i, j];
				invertedslp[k+1]=[i,j];
				[i,j]=[k+n, k+n+1];
				k++;
				invertedslp[k+1]=[i,j];
				m++;
			);
		,i==0,/*else if*/
			if(j<=n,
				/*[0,j] with j<=n, only for m-k=1*/
				if(k!=m-1, error("Invalid slp in slpinvert"));
				if(k==0,
					[i,j]=[0,s[j]];
				,/*else*/
					[i,j]=[k+n,s[j]];
				);	
				
			,/*else*/
				/*[0,j] with n<j*/
				if(k==0, 
					[i,j]=[-1,0];
				,k==m-1,/*else if*/
					error("Invalid slp in slpinvert");
				,/*else*/
					[i,j]=[0, k+n];
				);
			);
		,/*else*/
			/*[i,j] with i>0, j<=n*/
			if(k==0, 
				[i,j]=[0,s[j]];
			,/*else*/
				[i,j]=[k+n,s[j]];
			);
		);
		invertedslp[k+1]=[i,j];
	);
	return(invertedslp);
}


/*For linear slps. */
slptovec(slp,n)={
	my(i, j, v);
	v=List();
	for(k=1, #slp,
		[i,j]=slp[k];
		if(-n<=i && i<0,
			/*There k should be 1, otherwise the tree is*/
			/*disconnected that also means i should be <=n.*/
			for(m=1, sign(j)*j, listput(~v, sign(j)*(-i)));
		,i==0 && j<=n && k==1,/*else if*/
			listput(~v, j);
		,j<=n,/*else if*/
			/*j<=n*/
			listput(~v,j);
		,/*else*/
			error("Invalid slp, either not connected or not a line.")
		);
	);
	return(Vec(v));
}

/* Reciprocal of slptovec*/
vectoslp(v,n, {connect=1})={
	if(#v==0,
		return(v);
	);
	if(#v==1, return([[0,v[1]]]));
	my(pow, e, last);
	last=v[1]; e=v[2]; pow=1;
	while(e==last && pow<#v,
		pow++;
		last=v[pow];
		e=v[pow+1];
	);
	my(slp);
	if(pow==1,
		slp=[[0,v[1]]];
	,/*else*/
		slp=[[-(sign(v[1])*v[1]), sign(v[1])*pow]];
	);
	if(connect,
		slp=concat(slp, vector(#v-pow, u, [n+u, v[pow+u]]));
	,/*else*/
		slp=concat(slp, vector(#v-pow, u, [0, v[pow+u]]));
	);
	return(slp);
}

slpstovec(slps,n)={
	if(#slps==0, return(slps));
	my(vecs);
	vecs=vector(#slps,u, slptovec(slps[u],n));
	return(concat(vecs));
}

/* 
   Used to filter 2g generators and build a relation in buildpres
   function in rgraph.gp.
 */
buildrel_and_pointers(pointers, seed, s, s1, eindex, seen)={
	if(#pointers==1, return([pointers,[]]));
	my(e=seed, rel, j=1, newpointers, neweindex, m=0);
	neweindex=eindex;
	newpointers=vector(#pointers/2);
	rel=vector(#pointers);

	for(i=1, permorder(s),
		if(seen[s1[e]], 
			rel[i]=-neweindex[s1[e]];
			m++;
		,/*else*/
			newpointers[j]=pointers[i];
			j++;
			neweindex[e]+=-m;
			rel[i]=neweindex[e];
		);
		e=s[e];
	);
	\\error("");
	return([newpointers, rel]);
}
slp_normalize(slp, h, m)={
	my(i,j,n);
	n=#h;
	for(k=1, #slp,
		[i,j]=slp[k];
		if(i<0,
			if(-n<=i,
				i=-h[-i];
			,/*else*/
				i=i+n-m;
			);
		,i==0,/*else if*/
			if(j<=n,
				j=h[j];
			,/*else*/
				j=j-n+m;
			);
		,/*else*/
			if(i<=n,
				i=h[i]
			,/*else*/
				i=i-n+m;
			);
			if(j<=n,
				j=h[j];
			,/*else*/
				j=j-n+m;
			);
		);
		slp[k]=[i,j];
	);
	return(slp);
}
