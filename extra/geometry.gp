\\Computes if transformation needed to send
\\directed vector p1->p2 to the upper right
\\quarter of the plane reverses orientation
\\or not.
sign_inv(p1,p2)={
	if(p1==p2, return(0));
	my(x1,x2,y1,y2);
	[x1,y1]=p1;
	[x2,y2]=p2;
	my(tp, sign_inversion);
	if(x2-x1==0,
		sign_inversion=sign(y2-y1);
	,/*else*/
		if(y2-y1==0,
			sign_inversion=sign(x2-x1);
		,/*else*/
			sign_inversion=sign(x2-x1)*sign(y2-y1);
		);
	);
	return(sign_inversion);
}
\\ Separate R^2 in 8 half lines and
\\ 8 1/8'th of the plane.
\\ Cutting away the lines y=+-x, y=0, x=0.
\\ Assumes p1 is the origin of the plane.
\\ Returns [a, b] where b=1 if the directed
\\ half line from p1 to p2 is one of the
\\ cutted line or not. If not, a is the
\\ associated zone (from 1 to 8 going counter
\\ clock wise from y=0, x+.
pos_type(p1,p2)={
	my(p, slope, tp, sign_inversion);
	p=p2-p1;
	tp=(p[2]==p[1]||p[2]==-p[1]||p[2]==0||p[1]==0);
	if(!tp,
		sign_inversion=sign_inv(p1,p2);
		slope=p[2]/p[1];
		slope_pos=(1/2<slope*sign_inversion);
	);

	if(tp,
		postp=1*(p[2]==0 && 0<p[1])\
			+2*(p[2]==p[1] && 0<p[1])\
			+3*(p[1]==0 && 0<p[2])\
			+4*(p[2]==-p[1] && p[1]<0)\
			+5*(p[2]==0 && p[1]<0)\
			+6*(p[2]==p[1] && p[1]<0)\
			+7*(p[1]==0 && p[2]<0)\
			+8*(p[2]==-p[1] && 0<p[1]);
	,/*else*/
		if(sign_inversion-1,
			postp=4*(p[1]<0 && 0<p[2])+8*(0<p[1] && p[2]<0);
			postp=postp-slope_pos;
		,/*else*/
			postp=1*(0<p[1] && 0<p[2])+5*(p[1]<0 && p[2]<0);
			postp=postp+slope_pos;
		);
	);
	return([postp, tp, sign_inversion, slope]);
}

arctan(x)={
	return(real(-(log(1+I*x)-log(1-I*x))/2*I));
}
\\ See https://www.jstor.org/stable/27641866 for 
\\ better polynomials.
Arctan(x,{k=10})={
	if(x<0 || 1<x, error("arctan evaluated only in [0,1]."));
	my(p);
	p=vector(2*k+2);
	for(i=0,k,
		p[2*k+1-2*i]=((-1)^(i)/(2*(i)+1));
	);
	P=Pol(p, 'y);
	return(subst(P, y,x));
}

absolute_angle(p,{out="rad"})={
	my(postp, tp);
	[postp, tp, sign_inversion, slope]=pos_type([0,0], p);

	my(angle);
	if(tp,
		angle=(postp-1)*Pi/4;
	,/*else*/
		my(newslope);
		newslope=slope*sign_inversion;
		if(postp%2, 
			if(sign_inversion+1,
				angle=arctan(newslope);
			,/*else*/
				angle=Pi/2-arctan(1/newslope);
			);
		,/*else*/
			if(sign_inversion+1,
				angle=Pi/2-arctan(1/newslope);
			,/*else*/
				angle=arctan(newslope);
			);
		);
		angle=angle+floor((postp-1)/2)*Pi/2;
	);
	if(out=="rad",
		return(angle*1.);
	,out=="deg",/*else*/
		return(angle*360/(2*Pi));
	);
}

/*Polygones convexe implique faut tjr faire pm=-1*/
/*convention : tjr recoller vers le côté de l'orientation*/
/*quand c'est possible.*/
/*
In convention pm=1 and y1<y2, x1<x2, p is in the positive hyperplane 
generated by p1 and p2 if f(p[1])<p[2] where f is the
affine function that is y1 at x1 and y2 at x2. 
When x1=x2 and pm=1, p is in the positive hyperplane generated
by p1 and p2 if p[1]<x1.
*/
in_halfplane(l, p, pm)={
	my(p1,p2);
	[p1,p2]=l;
	if(p1==p2, error("p1=p2 in function in_halfplane"));
	my(x1,x2,y1,y2, in, slope);
	[x1,x2]=p1;
	[y1,y2]=p2;

	my(sign_inversion);
	\\ So that we can assume y1<y2 in first case and x1<x2 in
	\\ second case
	if(x2-x1==0,
		sign_inversion=sgn(y2-y1);
	,/*else*/
		sign_inversion=sgn(x2-x1);
	);
	my(y,f,sp);
	if(x2-x1==0,
		return(pm*sign_inversion*(p[1]<p[1]));
	,y2-y1==0,
		y=y1;
	,/*else*/
		sp=(y2-y1)/(x2-x1);
		f=(u)->(sp*(u-x1)+y1);
		y=f(p[1]);
	);
	in=pm*sign_inversion*(y<p[2]);
	return(in);
}

filter_halfplane(pts, l, pm)={
	my(p1,p2,in_p1p2_halfplane);
	[p1,p2]=l;
	\\ plus grand au plus petit
	in_p1p2_halfplane=(u)->(-in_halfplane(p1,p2,u,pm));
	pts=select(in_p1p2halfplane, pts);
	return(pts);
}
